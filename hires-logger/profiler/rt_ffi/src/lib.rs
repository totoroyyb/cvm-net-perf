// This crate provides the raw, unsafe FFI bindings to the C API
// of the C++ profiler runtime library.

// Option 1: Manually define the FFI function signatures
// This is simpler if bindgen is not used or causes issues.
// Ensure types match the C API header exactly (e.g., u32, u64, bool, usize).
// Use core::ffi types for portability.

use core::ffi::{c_char, c_void, c_uint, c_ushort, c_int}; // Add c_int if needed

// --- Manual FFI Definitions ---

// Opaque handle type
#[repr(C)] pub struct ProfilerConnectionHandle { _private: [u8; 0] }

// Re-define shared structs if needed by the API signatures, matching C layout.
// Ensure alignment and padding match C if you access fields directly (unsafe!).
// Prefer using the types generated by bindgen if possible.
#[repr(C)]
#[derive(Debug, Copy, Clone)] // Add traits as needed
pub struct log_entry_t {
    pub timestamp: u64,
    pub event_id: u32,
    pub cpu_id: u16,
    pub flags: u16,
    pub data1: u64,
    pub data2: u64,
}

// Define constants matching C header
pub const LOG_FLAG_VALID: u16 = 1 << 0;
pub const LOG_FLAG_KERNEL: u16 = 1 << 1;

// Define the shared_ring_buffer_t structure.
// WARNING: Manually defining complex structs with atomics and padding
//          is error-prone. Bindgen is strongly recommended here.
// This is a simplified placeholder - USE BINDGEN for the real struct.
#[repr(C)]
#[derive(Debug)]
pub struct shared_ring_buffer_t {
    // Placeholder fields - replace with bindgen output or exact C layout
    pub head: core::sync::atomic::AtomicUsize, // Assuming size_t maps to usize
    _pad0: [u8; 56], // Adjust padding based on actual size_t and cache line
    pub tail: core::sync::atomic::AtomicUsize,
    _pad1: [u8; 56],
    pub buffer_size: u64,
    pub size_mask: u64,
    pub dropped_count: core::sync::atomic::AtomicU64,
     _pad2: [u8; 40], // Adjust padding
    // Cannot represent the flexible array member directly here easily
    // Accessing the buffer usually requires pointer arithmetic from the base pointer.
    // pub buffer: [log_entry_t; 0], // Placeholder for flexible array idea
}


extern "C" {
    pub fn profiler_connect(device_path: *const c_char) -> *mut ProfilerConnectionHandle;
    pub fn profiler_disconnect(handle: *mut ProfilerConnectionHandle);
    pub fn profiler_log(
        handle: *mut ProfilerConnectionHandle,
        event_id: u32,
        data1: u64,
        data2: u64,
    ) -> bool;
    pub fn profiler_get_buffer(handle: *mut ProfilerConnectionHandle) -> *mut shared_ring_buffer_t;
    pub fn profiler_get_buffer_size(handle: *mut ProfilerConnectionHandle) -> usize;
    pub fn profiler_get_last_error() -> *const c_char;
}


/*
// Option 2: Include bindings generated by bindgen
// If using bindgen, replace the manual definitions above with this:
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(improper_ctypes)] // Allow bindgen's FFI types

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
*/